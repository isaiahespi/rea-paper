---
title: Data Import, Clean, and Process
format: 
  bookup-html:
    code-fold: false
    code-tools: true
    code-overflow: wrap
    code-copy: true
    code-annotations: true
---


## Set up

This document describes and executes the cleaning and processing of the survey data set downloaded from Qualtrics on 2024-10-23. Currently, this notebook is mainly to describe and explain the process undertaken in R to import, clean, wrangle, transform, and process the data set for later analysis. To see the process without all my explanatory text, see the relevant R script viewed [here](https://github.com/isaiahespi/rea-paper/blob/0bd7138259d244e9a046828fdcf09f2a33837b95/src/01-data.R).  

```{r}
#| label: setup
#| include: true
#| eval: true
#| echo: true

# set seed for reproducibility
set.seed(1234)

# load packages
library(tidyverse)
library(surveytoolbox)
library(labelled)
library(sjlabelled)
library(pewmethods)
library(fastDummies)

```



## Load data

Note that the 'raw' data set here has been sanitized of respondent's potentially sensitive information.

```{r}
#| label: load-data
#| echo: true

# load SPSS export from Qualtrics (includes display order vars)
# downloaded on 2024-10-29 at 12:02 PM
raw_spss_sanitized <- haven::read_sav("vmf_election_worker_recruitment_survey_raw_spss_sanitized_20241029_T12.02.sav")



```

## Create data dictionary and Survey Codebook

A data dictionary contains metadata about the data.
The the `data_dict()` function from R package [surveytoolbox](https://martinctc.github.io/surveytoolbox/) is used to create a *data dictionary* (i.e., codebook).
(alternatively, one can use the `generate_dictionary` from the [labelled](https://larmarange.github.io/labelled/) R package  to create a data dictionary with slightly different output.). This function produces a dataframe into the R environment with the number of observations (rows) equal to number of variables (columns) in the original data set. For ease, I prefer to save the codebook/data dictionary as a `.csv` file.

Also note that I use the native R pipe format ` |> ` (tip: try hotkey `CTRL + .`), which is essentially equivalent to the `magrittr` forward-pipe operator ` %>% `.

```{r}
#| label: raw-data-dict
#| echo: true

# data dictionary from labelled package.
raw_spss_sanitized_data_dict <- raw_spss_sanitized |> 
  surveytoolbox::data_dict()

```

The data dictionary is the same as a codebook, but I also wanted to have a codebook that contained **only** the survey questions, variable labels (`var`, i.e., question text), responses (`label_var`, i.e., value labels), and associated values (simply, `value`). So the saved `codebook` contains only the survey questions and the two grouping variables `qset` and `group`. The latter refers to the Experiment condition where `1 = Treatment` and `0 = Control`. The other grouping variable `qset` refers to two distinct question sets (A or B) which aren't as important to cover at the moment. 

I run the code below to generate a codebook that contains only the survey question items (`var`), the question test (`label_var`), value labels (`label_val`) and corresponding numeric codes (`value`). 

```{r}
#| label: survey_codebook

# create and save survey codebook

# this includes only the survey questions: question number (var), the question
# text (label_var), the value labels (label_val), and the numeric codes (value)
codebook <- raw_spss_sanitized |> 
  janitor::clean_names() |> 
  # get rid of superfluous Qualtrics columns
  # Keep Qualtrics `response_id`
  select(!1:7, !9:11, -q_data_policy_violations) |>
  # subset spss data set to omit the display order variables
  select(!contains("_do_")
         & !contains("_ado_")
         & !contains("_click")
         & !contains("_count")) |>
  select(contains("q"), group) |>
  surveytoolbox::data_dict()



```



## Filter Raw data

From the raw data set, there are `r dim(raw_spss_sanitized)[1]` observations in the data set (each observation is a row). The survey was programmed in such a way to automatically drop participants who, 

1.    Didn't consent to take part in the survey. 
2.    Were under 18 years of age[^1]
3.    Self-identified as not being a U.S. citizen
4.    Failed two attention checks embedded within the survey

Although the survey was programmed in this way, however, any responses of these participants were still recorded and included in the data. Survey participants may not have been dropped from participating in the survey until after they had already entered in a few responses, or at least responded to the first question requesting consent (Q1). Additionally, a respondent failing both attention checks would not have been dropped from the survey until the tenth question (Q10) within the survey, but their responses prior to being dropped would still be included in a row within the data set. This results in a lot of missing data (i.e., NA values) filling up observations (rows) in the data. The following code filters the data set to exclude any respondent who met the aforementioned exclusion criteria.

[^1]: The panel of participants gathered by Lucid already excluded anyone under 18 years of age, however a number of discrepancies were found between the age of respondents included in the Lucid embedded data and the age reported by the respondents themselves. However, the survey question asking the respondent's age was programmed so that respondents selected their age from a drop down menu. Since the lowest available option in the drop down list of ages was 18, there was no way for respondents who may have been under 18 to report their actual age from the drop down menu. Of course, it is always possible for any respondent to simply lie about their age, but this footnote is added for posterity.

```{r}
#| label: subset-data


data_spss <- raw_spss |> 
  tibble::rowid_to_column("rowID") |>   # <1>
  filter(Q1 == 1, # consent = 1         # <2>
         Q3 != 3,                       # <3>
         Q9 == 1 | Q9 == 0 & Q10 == 1   # <4>
         )

```

1.    Adds a column at the start of the dataframe (`rowID`) of sequential row ids starting at 1.
2.    Exclude anyone who didn't consent to partake in the survey
3.    Exclude non-U.S. citizens
4.    Exclude anyone who failed the two attention checks

This results in `r dim(data_spss)[1]` number of observations in the data set after excluding those who met the exclusion criteria. There are still a number of respondents who failed to fully complete the survey. These respondents either closed the survey prior to completion or failed to click the submit button at the end of the survey. They can be identified in the data set by the `Finished` variable in the data set where `Finished = 1`.

```{r}
#| label: finished-count

# identify and count the number of partial responses in the data
data_spss |> 
  group_by(finished) |> 
  count()

```

From the code above, I found that there were `125` participants who didn't complete the survey. It seemed important to identify the number of incomplete or partial responses in the data set considering subsequent analysis will have to take missing values into consideration. I decided to keep partial responses instead of dropping any respondent who didn't fully complete the survey. I reasoned that the responses were still validly recorded and because I could only speculate the reasons why so many respondents failed to complete the survey.  

## create dataframe from raw data

The following code is lengthy, but creates a dataframe (object class `tbl_df` `tbl` `data.frame`) assigned as `data_spss`.

```{r}
#| label: create-dataframe

# create dataframe
data_spss <- raw_spss |>
  janitor::clean_names() |>                                       # <1>
  select(!1:8 & !10:17 & !265) |>                                 # <2>
  relocate(q59:q74, .before = q1) |>                              # <3>
  dplyr::rename(
    q13_treat_time = q13_page_submit,
    q16_control_time = q16_page_submit,
    lucid_gender = gender,
    lucid_age = age,
    lucid_hhi = hhi,
    lucid_ethnicity = ethnicity,
    lucid_hispanic = hispanic,
    lucid_education = education,
    lucid_political_party = political_party,
    lucid_region = region,
    lucid_zip = zip,
    lucid_rid = rid,
    gender = q59,
    hisp = q60,
    race = q61,
    educ = q62,
    milserv1 = q63,
    milserv2 = q64,
    milservfam = q65,
    voted2020 = q66,
    choice2020 = q67,
    voteintent = q68,
    partyid = q69,
    partystr_rep = q70,
    partystr_dem = q71,
    partylean = q72,
    ideo = q73,
    ideolean = q74
  ) |>                                                           # <4>
  relocate(lucid_rid, .after = response_id) |>                   # <5>
  labelled::set_variable_labels(                                 # <6>
    lucid_age = "Lucid: age",
    lucid_gender = "Lucid: What is your gender?",
    lucid_hhi = "Lucid: What is your current Annual household income before taxes?",
    lucid_ethnicity = "Lucid: What is your race?",
    lucid_hispanic = "Lucid: Are you Hispanic, Latino, or Spanish Origin?",
    lucid_education = "Lucid: What is the highest level of education you have completed?",
    lucid_political_party = "Lucid: Generally Speaking, do you usually think yourself as a Republican, a Democrat, an Independent, or what?",
    lucid_region = "Lucid: For Region, ZIP is asked which is automatically mapped to the Region",
    lucid_zip = "Lucid: What is your ZIP code?",
    lucid_rid = "Lucid respondent ID",
    q1    = "Consent to Participate...",
    q28_1 = "There will be voter fraud...",
    q28_2 = "Many votes will not actually be counted",
    q28_3 = "Many people will show up to vote and be told they are not eligible",
    q28_4 = "A foreign country will tamper with the votes cast in Maricopa County, Arizona...",
    q28_5 = "Election officials in Maricopa County, Arizona will try to discourage some people from voting",
    q40_1 = "There will be voter fraud...",
    q40_2 = "Many votes will not actually be counted",
    q40_3 = "Many people will show up to vote and be told they are not eligible",
    q40_4 = "A foreign country will tamper with the votes cast in your local area...",
    q40_5 = "Election officials in your community will try to discourage some people from voting",

    q41_1 = "Election officials test every machine used in the election to ensure they are secure.",
    q41_2 = "Election officials conduct audits of ballots after every election...",
    q41_3 = "Poll watchers affiliated with the political parties or candidates observe the election.",
    q41_4 = "Election staff and volunteers include military veterans and their family members from the community.",
    q41_5 = "Election staff and volunteers include lawyers from the community.",
    q41_6 = "Election staff and volunteers include college students from the community.",
    
    q43_1 = "Election officials ensure that law enforcement officers are present at polling sites.",
    q43_2 = "Poll watchers affiliated with the political parties or candidates observe the election.",
    q43_3 = "People holding signs or giving out literature in support of a candidate or ballot question.",
    q43_4 = "Election staff and volunteers include military veterans and their family members from the community.",
    q43_5 = "Election staff and volunteers include lawyers from the community.",
    q43_6 = "Election staff and volunteers include college students from the community.",
    
    q44_1 = "Election officials test every machine used in the election to ensure they are secure.",
    q44_2 = "The majority of election staff and volunteers consist of military veterans and their family members from the community.",
    q44_3 = "The majority of election staff and volunteers consist of lawyers from the community.",
    q44_4 = "Election officials conduct audits of ballots after every election to confirm the results were accurate.",
    q44_5 = "Poll watchers affiliated with the political parties or candidates observe the election.",
    q44_6 = "The majority of election staff and volunteers consist of college students from the community.",
    
    q46_1 = "Election officials ensure that law enforcement officers are present at polling sites.",
    q46_2 = "The majority of election staff and volunteers consist of military veterans and their family members from the community.",
    q46_3 = "The majority of election staff and volunteers consist of lawyers from the community.",
    q46_4 = "Poll watchers affiliated with the political parties or candidates observe the election.",
    q46_5 = "The majority of election staff and volunteers consist of college students from the community.",
    q46_6 = "People holding signs or giving out literature in support of a candidate or ballot question.",
    group = "Experimental condition",
    qset = "A = question set [q41, q43]; B = question set [q44, q46]"
  )


```

1.    The `janitor` R package is used to `clean_names()` which ensures the column names of the dataframe are unique, consist only of the '_' character, numbers, and letters. All uppercase column names will be converted to lowercase (e.g., Q1 to q1).
2.    The `dplyr::select()` selectively removes superfluous columns that come standard when survey data is downloaded from Qualtrics. 
2.    Keep Qualtrics `response_id`
3.    Use `dplyr::relocate()` to relocate demographic variables (e.g., Q59 to Q74) to a position just before the Q1 column
4.    Use `dplyr::rename()` functions to rename demographic vars and timing vars and identify Lucid variables
5.    Use `dplyr::relocate()` to put the Lucid rid ('lucid_rid') to a position just after the Qualtrics Response ID ('response_id')
6.    Use `labelled::set_variable_labels()` to set the *variable labels* attached to each respective variable[^1].


[^1]: *Variable* labels differ from *value* labels. The variable labels of this data set contain the question text of the particular survey question, truncated for some. For more detailed explanation and guidance on working with labelled data, usually imported from an SPSS .sav file, see the following resources: Shannon Pileggi's [Leveraging labelled data in R](https://www.pipinghotdata.com/posts/2020-12-23-leveraging-labelled-data-in-r/) and [The case for variable labels in R](https://www.pipinghotdata.com/posts/2022-09-13-the-case-for-variable-labels-in-r/); Joseph Larmarange's R package [labelled](https://larmarange.github.io/labelled/); and Daniel Lüdecke's [Labelled Data and the sjlabelled-Package](https://strengejacke.github.io/sjlabelled/articles/intro_sjlabelled.html) and the [sjlabelled package](https://strengejacke.github.io/sjlabelled/index.html). Also see Martin Chan's R package [surveytoolbox](https://martinctc.github.io/surveytoolbox/) which is also very helpful for [Working with SPSS labels in R](https://martinctc.github.io/blog/working-with-spss-labels-in-r/).  

## Resolving errors in data

The responses to the age survey question (`Q2`) in the dataframe (`data_spss`) reflect the response code rather than the respondent's actual reported age as selected from the drop-down list of ages ranging from '18' to '90 or
older'. Since age was indicated using a drop down list, the first response is coded as `1` which corresponds to age 18 in years. In addition, embedded data from Lucid also reflects the respondent's age, which has been renamed to `lucid_age`. The following code is used to illustrate this discrepancy.

```{r}
#| label: age-discrepancies
#| echo: true
#| output: true

# verify that `age` and `q2` do not match at all in the numeric data frame
# due to `q2` reflecting codes, not ages
# note `lucid_age` is a character class object which is temporarily treated 
# as numeric
data_spss |> 
  dplyr::select(lucid_age, q2) |> 
  dplyr::mutate(
    "match" = ifelse(as.numeric(lucid_age) == q2, "match", "no match")) |> 
  head(10)

```

The output displays the first 10 observations and no match is found comparing the numeric values of the two variable columns. Note, however, that the `lbl` of `q2` do, in fact, match the `lucid_age` values[^2].

[^2]: At this point, most of the variable objects of the dataframe are class `"haven_labelled"` `"vctrs_vctr"` `"double"`, which means that the variable object in R has numeric values with *value labels* attached, hence `<dbl+lbl>`. According to description of the `labelled()` function in the `haven` R package, "A labelled vector is a common data structure in other statistical environments, allowing you to assign text labels to specific values. This class makes it possible to import such labelled vectors in to R without loss of fidelity."

As such, the variable `q2` cannot simply be converted to numeric (class) using the `as.numeric()` function because value label (i.e., the `'lbl'` in `<dbl+lbl>`) would be dropped, leaving the age values to incorrectly reflect the response codes rather than the actual age of the respondent. To resolve this problem, I use `dplyr::mutate()` and `dplyr::case_match()` to re-name the variable column and re-code the values to reflect the correct age and convert the object to a numeric class. Admittedly, this was quite tedious.
   

```{r}
#| label: numeric-age-fix

data_spss <- data_spss |>
  # rename `q2` to 'age' and recode values
  dplyr::mutate(
    q2 = dplyr::case_match(
      q2,
      1 ~ 18,
      2 ~ 19,
      3 ~ 20,
      4 ~ 21,
      5 ~ 22,
      6 ~ 23,
      7 ~ 24,
      8 ~ 25,
      9 ~ 26,
      10 ~ 27,
      11 ~ 28,
      12 ~ 29,
      13 ~ 30,
      14 ~ 31,
      15 ~ 32,
      16 ~ 33,
      17 ~ 34,
      18 ~ 35,
      19 ~ 36,
      20 ~ 37,
      21 ~ 38,
      22 ~ 39,
      23 ~ 40,
      24 ~ 41,
      25 ~ 42,
      26 ~ 43,
      27 ~ 44,
      28 ~ 45,
      29 ~ 46,
      30 ~ 47,
      31 ~ 48,
      32 ~ 49,
      33 ~ 50,
      34 ~ 51,
      35 ~ 52,
      36 ~ 53,
      37 ~ 54,
      38 ~ 55,
      39 ~ 56,
      40 ~ 57,
      41 ~ 58,
      42 ~ 59,
      43 ~ 60,
      44 ~ 61,
      45 ~ 62,
      46 ~ 63,
      47 ~ 64,
      48 ~ 65,
      49 ~ 66,
      50 ~ 67,
      51 ~ 68,
      52 ~ 69,
      53 ~ 70,
      54 ~ 71,
      55 ~ 72,
      56 ~ 73,
      57 ~ 74,
      58 ~ 75,
      59 ~ 76,
      60 ~ 77,
      61 ~ 78,
      62 ~ 79,
      63 ~ 80,
      64 ~ 81,
      65 ~ 82,
      66 ~ 83,
      67 ~ 84,
      68 ~ 85,
      69 ~ 86,
      70 ~ 87,
      71 ~ 88,
      72 ~ 89,
      73 ~ 92 # one person reported '90 or older'. R's age in Lucid data is 92
    ),
    .keep = "unused" # drop `q2` from dataframe
  ) |> 
  # set variable label consisting of question text
  labelled::set_variable_labels(q2 = "What is your age?")


```

It is still possible that the `lucid_age` variable doesn't match the re-coded `q2` values. In fact, this is the case, as demonstrated by running the code below.

```{r}
#| label: lucid-age-discrepancies
#| echo: true
#| output: true

# Identify counts of discrepancies between `lucid_age` and 'age'
data_spss |> 
  dplyr::select(rowID, lucid_age, age) |> 
  dplyr::mutate(match = ifelse(age == lucid_age, TRUE, FALSE)) |>
  dplyr::summarise(
    "Matches" = sum(match == TRUE, na.rm = T),
    "Non-match" = sum(match == FALSE, na.rm = T)
  )


```

What results is confirmation that there are a total of 170 discrepancies between the respondent's age as indicated by the embedded Lucid data and the age reported by the respondent in the survey. The age reported by the respondent in the survey will take precedence over the embedded data provided by Lucid[^3].

[^3]: Note, however, that one of the response options for the question "What is your age?" (`q2`) was "90 or older", and one respondent's age reported by Lucid was 92 years old. Since there was no response code associated with being 92 years of age, the response code `73` was recoded to represent 92. In this one case, it was a stroke of luck that no more than one of the survey respondents happened to be 90 years of age or older. If there was, however, then there would have been no way to recode the `q2` variable to reflect those respondent's actual age *and* convert the variable object to a numeric class. This issue isn't insurmountable, of course, but the lesson here is to ensure respondents manually enter their age or birth year in the survey rather than choose from a drop down list of options.

## Recode variables to identify question display order  

Survey question items `Q51` to `Q58` were split up into two question sets: `Q51` to `Q54` and `Q55` to `Q58`. The order of these question sets were randomly reversed. For order 1, questions `Q51` to `Q54` ('agent-aim') were presented first, followed by the next set, `Q55` to `Q58` ('agent-action-aim'). For order 2, the presentation was reversed. Two variable columns in the data set identify the question display order. Here I use those two variables to construct a single dummy variable where order 1 = 1, and order 2 = 0.

```{r}
#| label: popeff-qdo

# create var to identify display order of popular efficacy questions
data_spss <- data_spss |>
  dplyr::mutate(
    popeff_qdo = dplyr::case_when(
      fl_22_do_popular_efficacy_agent_aim == 1 &
        fl_22_do_popularefficacy_agent_action_aim == 2 ~ 1,
      fl_22_do_popular_efficacy_agent_aim == 2 &
        fl_22_do_popularefficacy_agent_action_aim == 1 ~ 0
    ),
    .after = qset,
    .keep = "unused"
  )
```

## Create dataframe with factors 

As mentioned previously, labelled (SPSS) data is, well, labelled; the labelled variables are `<dbl+lbl>` which differs from factors `<fct>`[^4]. The following creates a new dataframe where the all the labelled variables `<dbl+lbl>` are converted to factors using `haven::as_factor()`. 

```{r}
#| label: data-clean

# covert all <dbl+lbl> vars to factor <fct> vars
# remove all display order variables, as well as click counts
# specifically convert `group` and `qset` to factor vars and set value labels
# with associated values, i.e, levels with labels
# re-code all blank levels "" to NA

data <- data_spss |>
  # subset spss data set to omit the display order variables
  dplyr::select(!contains("_do_")
         & !contains("_ado_")
         & !contains("_click")
         & !contains("_count")) |>
  
  # make `group` and `qset` factors
  dplyr::mutate(
    group = forcats::fct(group, levels = c("Treatment", "Control")),
    qset = forcats::fct(qset, levels = c("A", "B"), na = "")
  ) |>
  
  # adds labels as attribute (named "labels") to group and qset, assign values
  sjlabelled::set_labels(group, labels = c("Treatment" = 1, "Control" = 0)) |>
  sjlabelled::set_labels(qset, labels = c("A" = 1, "B" = 0)) |>
  
  # convert all labelled variables in dataframe to factors
  haven::as_factor(only_labelled = T) |>
  
  # re-code any empty/blank levels to NA
  dplyr::mutate(dplyr::across(where(is.factor), 
                              ~ forcats::fct_recode(., NULL = ""))) |>
  
  # reverse order of identified factor levels for consist direction
  dplyr::mutate(dplyr::across(c(q8, q20, q23, q24, q31, q34, q35, q49, q50), 
                .fns = ~ forcats::fct_rev(.))) |>
  
  # reverse order of group levels so control comes first. Better table display
  mutate(group = forcats::fct_rev(group))


```


In addition, the following unnecessary variables are removed...

-   variable columns that indicate the display order of survey questions and the response option display order (e.g., `q5_do`, `q28_ado`)
-   variable columns related to timing spent on a particular page: the first click, number, or count of clicks (e.g., `q13_first_click`, `q13_last_click`, `q13_click_count`)

The `group` variable identifies whether a survey respondent was in the "Treatment" or "Control" condition. The `qset` variable identifies which question set a respondent answered; set "A" indicates the respondent was presented `Q41` and `Q43`, whereas set "B" indicates the respondent was presented `Q44` and `Q46` instead. Each of these variables were converted to factors using `forcats::fct()` prior to running `haven::as_factor()` because each is an object of class `character`. By default, `haven::as_factor()` applies `forcats::as_factor()` only to labelled variables in the dataframe. Since `group` and `qset` do no contain an associated *value* nor a *value label*, they would not be converted to class `factor`[^5]. The default argument of the function could be set to FALSE (i.e., `haven::as_factor(only_labelled = FALSE)`), but this would then convert **all** variables in the dataframe to factors, which is problematic considering the numeric variables that need to be preserved as such. 

[^4]: Factors (variable objects of class `factor`) are used for categorical variables in R. Mostly. To learn more, see the chapter on Factors in [R for Data Science](https://r4ds.hadley.nz/factors) by Hadley Wickham, Mine
      Çetinkaya-Rundel, and Garrett Grolemund.

[^5]: Of course, I could have simply used `dplyr::mutate(x = haven::as_factor(x))` again after running `as_factor()` for the whole dataframe, but this resulted in weirdness with the two variables that I didn't want to investigate and resolve. 

Moreover, any blank levels are recoded to `NA`. Finally, an identified set of factor variables in the dataframe needed to have the orders of their levels reversed to remain consistent. Later, a similar, but different, operation is executed for the purely numeric dataframe. 


## Putting variable labels back into factor dataframe

It's easier to analyze variables in data as factors, but losing the variable labels (i.e., question text) is kind of a bummer. Variable labels are nice to have for plenty of reasons. The following puts the variable labels from the labelled (SPSS) data set back into the 'factor-ized' dataset.

```{r}
#| label: put-var-labels-back

# To quickly assign the variable labels, first create a named vector via
# deframe() with values as the variable labels and names as the variable names.
data_labels <- data_spss_dict |>
  dplyr::select(variable, label) |> 
  tibble::deframe()

# Now assign the labels using the splice operator. Using the splice operator,
# labels are assigned via matching against the variable name, which means that
# variable order does not matter.
data <- data |> 
  labelled::set_variable_labels(!!!data_labels)

```

## Add Variables to the dataframe

Here I construct the `partyid_3cat` variable from partisanship-related variables in the dataframe. Simply, this variable simplifies a respondent's self-reported party identification into either Democrat, Republican, or Independent by re-coding and combining responses to survey questions Q69, Q70, Q71, and Q72. I combined everyone who indicates some attachment to either the Democrat or Republican party (e.g., "Strong" and "Not very strong") to include self-described Independents who reportedly 'lean' more towards one party over the other. So, strong and weak Democrats as well as those who lean Democratic are all lumped into the Democrat group, and likewise for Republicans. Independents in this case only consist of true or 'pure' independents who don't think of themselves as Democrat or Republican and don't think of themselves as closer to either political party. 

```{r}
#| label: add-partyid_3cat

# construct the partyid var with 3 categories, true independents
data <- data |>
  dplyr::mutate(
    partyid_3cat = pewmethods::fct_case_when(
      partyid == "Republican" ~ "Republican",
      partystr_rep == "Strong" ~ "Republican",
      partystr_rep == "Not very strong" ~ "Republican",
      partylean == "Republican" ~ "Republican",
      partyid == "Democrat" ~ "Democrat",
      partystr_dem == "Strong" ~ "Democrat",
      partystr_dem == "Not very strong" ~ "Democrat",
      partylean == "Democratic" ~ "Democrat",
      partyid == "Independent" ~ "Independent",
      partyid == "Other" ~ "Independent",
      partylean == "Neither" ~ "Independent"
    ),
    .before = partyid) |> 
  labelled::set_variable_labels(
    partyid_3cat = "Party ID 3 categories, with true Independents")



```

Next I construct a variable consisting of eight age groups: 18-24, 25-34, 35-44, 45-54, 55-64, 65-74, 75-84, and 85-92 years of age.


```{r}

# create an age group variable
data <- data |>    
  dplyr::mutate(age_cat = 
           forcats::fct_collapse(
             forcats::as_factor(age),
             "18-24" = c(18:24),
             "25-34" = c(25:34),
             "35-44" = c(35:44),
             "45-54" = c(45:54),
             "55-64" = c(55:64),
             "65-74" = c(65:74),
             "75-84" = c(75:82, 84),
             "85-92" = c(85:88, 92)
             ),
         .after = age) |> 
  labelled::set_variable_labels(
    age_cat = "Age categorized into eight groups"
  )


```

Here I collapse the gender variable into gender_3cat, and voted2020 into voted2020.clps.

```{r}


df <- df |> 
  dplyr::mutate(gender_3cat = forcats::fct_collapse(
    gender,
    "Male" = "Male",
    "Female" = "Female",
    "Other/Refused" = c("Non-binary / third gender", "Prefer not to say")),
    voted2020.clps = forcats::fct_collapse(
      voted2020,
      "Voted" = "Yes, I'm sure I voted",
      "Didn't vote" = c("I'm sure I didn't vote", "I don't think I voted"),
      "Unsure/Ineligible" = c("I think I voted","I was not eligible to vote")
      )) |>
  labelled::set_variable_labels(
    voted2020.clps = "Turnout 2020"
  )



```



## Dummify and Collapse Factors

Most survey items consisted of Likert-type items with four or five response options to choose from. Many response items were ordinal in nature, with four options ranging from "Not at all___", "Not too \___", to "Somewhat \___",  "Very ___" or "Always". Collapsing such response options into two levels is done to illustrate comparison and highlight treatment effects should any be present between treatment and control groups. For instance, to illustrate distinction between expressing concern and expressing little to no concern about potential violence at polling sites, the four levels of the `q25` factor variable were collapsed into two levels, "not_concerned" and "concerned". The modified variable name was affixed with `.clps` to distinguish it in the dataframe. For survey items `Q41` through `Q46` where there were five response options, factor levels were collapsed into three levels where a neutral middle option was maintained: "Increase confidence", "No impact", and "Decrease confidence". 


```{r}
#| label: add-dummy

# collapse categorical variables with 4-point response items into factors with
# two levels. Those with 5-point response options are converted into factors
# with 3 levels. Affix ".clps" to colname to identify collapsed factor vars,
# e.g., q19.clps

df <- df |>
  dplyr::mutate(across(
    c(q19, q20, q22, q23, q24, q26, q30, q31, q33, q34, q35, q37),
    ~ forcats::fct_collapse(
      .,
      Not_confident = c("Not at all confident", "Not too confident"),
      Confident = c("Somewhat confident", "Very confident")
    ),
    .names = "{.col}.clps"
  )) |>
  dplyr::mutate(across(
    c(q21, q32),
    ~ forcats::fct_collapse(
      .,
      not_committed = c("Not at all committed", "Not too committed"),
      committed = c("Somewhat committed", "Very committed")
    ),
    .names = "{.col}.clps"
  )) |>
  # whoops. Need to change "somewhat unconcerned" to "Not too concerned"
  # recall: fct_recode(x, old_level = new_level)
  dplyr::mutate(
    q36 = forcats::fct_recode(
      q36,
      "Not at all concerned" = "Not at all concerned",
      "Not too concerned" = "Somewhat unconcerned",
      "Somewhat concerned" = "Somewhat concerned",
      "Very concerned" = "Very concerned"
    )
  ) |>
  dplyr::mutate(across(
    c(q25, q36),
    ~ forcats::fct_collapse(
      .,
      not_concerned = c("Not at all concerned", "Not too concerned"),
      concerned = c("Somewhat concerned", "Very concerned")
    ),
    .names = "{.col}.clps"
  )) |>
  dplyr::mutate(q38.clps =
           forcats::fct_collapse(
             q38,
             unsafe = c("Not safe at all", "Not too safe"),
             safe = c("Somewhat safe", "Very safe")
           )) |>
  dplyr::mutate(across(
    c(q27, q39),
    ~ forcats::fct_collapse(
      .,
      disapprove = c("Strongly disapprove", "Somewhat disapprove"),
      approve = c("Somewhat approve", "Strongly approve")
    ),
    .names = "{.col}.clps"
  )) |>
  dplyr::mutate(q29.clps = forcats::fct_collapse(
    q29,
    oppose = c("Definitely should not adopt", "Probably should not adopt"),
    support = c("Probably should adopt", "Definitely should adopt")
  )) |> 
  dplyr::mutate(across(q28_1:q28_5 | q40_1:q40_5,~forcats::fct_collapse(
    .,
    Not_likely = c("Not likely at all", "Not too likely"),
    Likely = c("Somewhat likely", "Very likely")),
    .names = "{.col}.clps"
    )) |>
  dplyr::mutate(
    across(
      q41_1:q41_6 |
        q43_1:q43_6 | q44_1:q44_6 | q46_1:q46_6,
      ~ forcats::fct_collapse(
        .,
        decrease = c("Decrease confidence a lot", "Decrease confidence somewhat"),
        no_impact = "No impact on confidence",
        increase = c("Increase confidence somewhat", "Increase confidence a lot")
      ),
    .names = "{.col}.clps"
    )
  )



```


Variable labels are important for presentation purposes but the length of the survey question text is too long to fit neatly into a table or figure. Here I add labels to the modified and collapsed factor variables. I also reorder the variable columns in the data frame using `dplyr::relocate()`.

```{r}

# set shorter levels for some demographic vars
df <- df |> labelled::set_variable_labels(
  gender_3cat = "What is your current gender?",
  race = "Primary race reported by respondent",
  educ = "Highest level of education completed",
  milserv1 = "Have you ever served in the Armed Forces?",
  milserv2 = "Are you now serving in the Armed Forces?",
  milservfam = "Member of immediate family served or is currently serving",
  choice2020 = "Who did you vote for?",
  voteintent = "Do you plan to vote?"
)

df <- df |>
  labelled::set_variable_labels(
    q5         = "Attention to Political Affairs",
    q6         = "EO Favorability",
    q7         = "Legitimacy of 2020 election",
    q8         = "General Trust in others",
    q19.clps   = "Confidence vote counts will be accurate, AZ",
    q20.clps   = "Competence of Election Staff, AZ",
    q21.clps   = "Commitment of Election Staff, AZ",
    q22.clps   = "Fair Process, AZ",
    q23.clps   = "Fair Outcomes, AZ",
    q24.clps   = "Security of Voting Tech, AZ",
    q25.clps   = "Voters Will Be Free From Intimidation/Violence, AZ",
    q26.clps   = "Safe In-person Voting, AZ",
    q27.clps   = "Election Official Approval, AZ",
    q28_1.clps = "Voter fraud, AZ",
    q28_2.clps = "Votes won't be counted, AZ",
    q28_3.clps = "People will turned away, AZ",
    q28_4.clps = "Foreign interference with votes, AZ",
    q28_5.clps = "EOs discourage people from voting, AZ",
    q29.clps   = "Adopt AZ Program",
    q30.clps   = "Accurate counts, Local",
    q31.clps   = "Competence of Election Staff, Local" ,
    q32.clps   = "Commitment of Election Staff, Local",
    q33.clps   = "Fair Process, Local",
    q34.clps   = "Fair Outcomes, Local",
    q35.clps   = "Secure Voting Tech, Local",
    q36.clps   = "Voter Intimidation/Violence, Local",
    q37.clps   = "Safe in-person voting, Local",
    q38.clps   = "Safe to vote in-person, Local",
    q39.clps   = "EO Approval, Local",
    q40_1.clps = "Voter fraud, Local",
    q40_2.clps = "Votes won't be counted, Local",
    q40_3.clps = "People will be turned away, Local",
    q40_4.clps = "Foreign interference with votes, Local",
    q40_5.clps = "EO discourage people from voting, Local",
    
    q41_1.clps = "Election officials test machines",
    q41_2.clps = "Election officials conduct audits",
    q41_3.clps = "Partisan Poll watchers observe the election.",
    q41_4.clps = "Election staff include veterans and family",
    q41_5.clps = "Election staff include lawyers",
    q41_6.clps = "Election staff include college students",
    
    q43_1.clps = "Law enforcement presence.",
    q43_2.clps = "Partisan Poll watchers observe the election",
    q43_3.clps = "People holding signs or giving out literature",
    q43_4.clps = "Election staff includes veterans",
    q43_5.clps = "Election staff includes lawyers",
    q43_6.clps = "Election staff includes students",
    
    q44_1.clps = "Election officials test machines",
    q44_2.clps = "Majority of Election staff are veterans",
    q44_3.clps = "Majority of Election staff are lawyers",
    q44_4.clps = "Election officials conduct audits",
    q44_5.clps = "Partisan Poll watchers observe the election",
    q44_6.clps = "Majority of Election staff are students",
    
    q46_1.clps = "Law enforcement presence.",
    q46_2.clps = "Majority of Election staff are veterans",
    q46_3.clps = "Majority of Election staff are lawyers",
    q46_4.clps = "Partisan Poll watchers observe the election",
    q46_5.clps = "Majority of Election staff are students",
    q46_6.clps = "People holding signs or giving out literature",
  )


# Now do some heavy duty relocating of columns in the dataframe
df <- df |>  
  dplyr::relocate(
    gender_3cat, .after = gender
  ) |> 
  dplyr::relocate(
    voted2020.clps, .after = voted2020
  ) |>
  dplyr::relocate(
  c(
    q20.clps,
    q21.clps,
    q22.clps,
    q23.clps,
    q24.clps,
    q25.clps,
    q26.clps,
    q27.clps,
    q28_1.clps,
    q28_2.clps,
    q28_3.clps,
    q28_4.clps,
    q28_5.clps,
    q29.clps,
    q30.clps,
    q31.clps,
    q32.clps,
    q33.clps,
    q34.clps,
    q35.clps,
    q36.clps,
    q37.clps,
    q38.clps,
    q39.clps,
    q40_1.clps,
    q40_2.clps,
    q40_3.clps,
    q40_4.clps,
    q40_5.clps,
    q41_1.clps,
    q41_2.clps,
    q41_3.clps,
    q41_4.clps,
    q41_5.clps,
    q41_6.clps,
    q43_1.clps,
    q43_2.clps,
    q43_3.clps,
    q43_4.clps,
    q43_5.clps,
    q43_6.clps,
    q44_1.clps,
    q44_2.clps,
    q44_3.clps,
    q44_4.clps,
    q44_5.clps,
    q44_6.clps,
    q46_1.clps,
    q46_2.clps,
    q46_3.clps,
    q46_4.clps,
    q46_5.clps,
    q46_6.clps
  ),
  .after = q19.clps)

```

# Merge question sets that have no significant differences between them

The `Qset` variable (which stands for 'Question set') identified respondents who responded to question set 'A' and those who responded to question set 'B'. The two question sets contained a pair of matrix-style (i.e., grid) questions where survey participants responded to a series of six statements per question. To be clear, each question set contained two questions and each question contained a series of six statements. The question sets differed only in the wording that was used in some, but not all, of the question item statements. Those in `Qset A` responded to `Q41` and `Q43`, whereas those assigned to `Qset B` responded to `Q44` and `Q46`. After some preliminary analysis was conducted, no significant differences in proportion of responses were found between `Qset A` and `Qset B`, which allowed the question sets to be combined, or coalesced. The code below does just that, as well as assigns variable labels.


```{r}

# merge (or coalesce) the qset vars that can be merged. 
# The following merges vars from the q44 and q46 set into q41 and q43. `qset` A
# was presented to one half of the respondents, whereas `qset` B was presented
# to the other half. Because of this, the variable columns in the dataframe for
# each question in the series contains missing values representing this fact.
# Below I coalesce the `qset` B question items with `qset` A. The function finds
# the first non-missing value at each position, allowing me to generate a
# complete vector that contains the responses to the series of questions from
# either set. I am able to distinguish between the different question sets since
# they are still grouped by the `qset` variable.

df <- df |> 
  group_by(rowID) |> 
  mutate(q41.1 = dplyr::coalesce(q41_1, q44_1),
         q41.2 = dplyr::coalesce(q41_2, q44_4),
         q41.3 = dplyr::coalesce(q41_3, q44_5),
         q41.4 = dplyr::coalesce(q41_4, q44_2),
         q41.5 = dplyr::coalesce(q41_5, q44_3),
         q41.6 = dplyr::coalesce(q41_6, q44_6),
         
         q43.1 = dplyr::coalesce(q43_1, q46_1),
         q43.2 = dplyr::coalesce(q43_2, q46_4),
         q43.3 = dplyr::coalesce(q43_3, q46_6),
         q43.4 = dplyr::coalesce(q43_4, q46_2),
         q43.5 = dplyr::coalesce(q43_5, q46_3),
         q43.6 = dplyr::coalesce(q43_6, q46_5),
         
         q41.1.clps = dplyr::coalesce(q41_1.clps, q44_1.clps),
         q41.2.clps = dplyr::coalesce(q41_2.clps, q44_4.clps),
         q41.3.clps = dplyr::coalesce(q41_3.clps, q44_5.clps),
         q41.4.clps = dplyr::coalesce(q41_4.clps, q44_2.clps),
         q41.5.clps = dplyr::coalesce(q41_5.clps, q44_3.clps),
         q41.6.clps = dplyr::coalesce(q41_6.clps, q44_6.clps),
         
         q43.1.clps = dplyr::coalesce(q43_1.clps, q46_1.clps),
         q43.2.clps = dplyr::coalesce(q43_2.clps, q46_4.clps),
         q43.3.clps = dplyr::coalesce(q43_3.clps, q46_6.clps),
         q43.4.clps = dplyr::coalesce(q43_4.clps, q46_2.clps),
         q43.5.clps = dplyr::coalesce(q43_5.clps, q46_3.clps),
         q43.6.clps = dplyr::coalesce(q43_6.clps, q46_5.clps)
         ) |>
  ungroup() |> 
  
  # add variable labels to coalesced variables
  sjlabelled::var_labels(
    q41.1 = "Election officials test machines",
    q41.2 = "Election officials conduct audits",
    q41.3 = "Partisan Poll watchers observe the election.",
    q41.4 = "Election staff includes/is majority of veterans and family",
    q41.5 = "Election staff includes/is majority of lawyers",
    q41.6 = "Election staff includes/is majority of college students",
    
    q43.1 = "Election officials test machines",
    q43.2 = "Election officials conduct audits",
    q43.3 = "Partisan Poll watchers observe the election.",
    q43.4 = "Election staff includes/is majority of veterans and family",
    q43.5 = "Election staff includes/is majority of lawyers",
    q43.6 = "Election staff includes/is majority of college students",
    
    q41.1.clps = "Election officials test machines",
    q41.2.clps = "Election officials conduct audits",
    q41.3.clps = "Partisan Poll watchers observe the election.",
    q41.4.clps = "Election staff includes/is majority of veterans and family",
    q41.5.clps = "Election staff includes/is majority of lawyers",
    q41.6.clps = "Election staff includes/is majority of college students",
    
    q43.1.clps = "Election officials test machines",
    q43.2.clps = "Election officials conduct audits",
    q43.3.clps = "Partisan Poll watchers observe the election.",
    q43.4.clps = "Election staff includes/is majority of veterans and family",
    q43.5.clps = "Election staff includes/is majority of lawyers",
    q43.6.clps = "Election staff includes/is majority of college students"
  )


```

Finally, dummy variables were created from the newly coalesced variables where 1 = "Increase in confidence" and 0 = "No impact" or "Decrease in confidence". This was done for the sake of conducting comparisons between treatment and control groups.

```{r}

# create dummy variables where 1 = 'Increase in confidence' and 0 = "No increase
# in confidence".
# add dummy variables to dataframe
# this is to test treatment effects
df <- df |> 
  mutate(across(c(q41.1.clps:q43.6.clps), 
                ~ dplyr::case_when(
                . == "increase" ~ 1, 
                . == "no_impact" ~ 0,
                . == 'decrease' ~ 0
                ), .names = "{.col}.dum")) |> 
  # add variable labels
  sjlabelled::var_labels(
    q41.1.clps.dum = "Election officials test machines",
    q41.2.clps.dum = "Election officials conduct audits",
    q41.3.clps.dum = "Partisan Poll watchers observe the election.",
    q41.4.clps.dum = "Election staff includes/is majority of veterans and family",
    q41.5.clps.dum = "Election staff includes/is majority of lawyers",
    q41.6.clps.dum = "Election staff includes/is majority of college students",
    q43.1.clps.dum = "Election officials test machines",
    q43.2.clps.dum = "Election officials conduct audits",
    q43.3.clps.dum = "Partisan Poll watchers observe the election.",
    q43.4.clps.dum = "Election staff includes/is majority of veterans and family",
    q43.5.clps.dum = "Election staff includes/is majority of lawyers",
    q43.6.clps.dum = "Election staff includes/is majority of college students"
  )

```


## Save the dataframe

All that is left to do is to save the dataframe that is now ready for further analysis. Remove the unnecessary data frames that may be clogging up the working environment.

```{r}

# save df processed data set.
save(df, file = "data/research-paper-df-2024-09-11.Rdata")
write.csv(df, file = "data/research-paper-df-2024-09-11.csv")


# save a data dict that can be saved as .csv
# generate data dictionary
df_dictionary <- surveytoolbox::data_dict(df)
write.csv(df_dictionary, file = "data/df_dictionary.csv")


# remove uneeded dataframes from global environment ::::::::::::::::::::::::####
rm(data, data_dict_spss, data_spss, raw_spss, raw_spss_dict, data_labels)


```

